
## a) Identify a couple of examples on the use of AssertJ expressive methods chaining.  

    In EmployeeRepositoryTest.java :  
        . assertThat( found ).isEqualTo(alex);  
        . assertThat(fromDb).isNull();  
        . assertThat(fromDb).isNotNull();  
        . assertThat(fromDb.getEmail()).isEqualTo( emp.getEmail());  
        . assertThat(fromDb).isNull();  
        . assertThat(allEmployees).hasSize(3).extracting(Employee::getName).containsOnly(alex.getName(), ron.getName(), bob.getName());

    In EmployeeRestControllerIT.java:  
        . assertThat(found).extracting(Employee::getName).containsOnly("bob");  

    In EmployeeRestControllerTemplateIT.java:  
        . assertThat(found).extracting(Employee::getName).containsOnly("bob");  
        . assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);  
        . assertThat(response.getBody()).extracting(Employee::getName).containsExactly("bob", "alex");  

    In EmployeeService_UnitTest.java:  
        . assertThat(found.getName()).isEqualTo(name);
        . assertThat(fromDb).isNull();  
        . assertThat(doesEmployeeExist).isEqualTo(true);  
        . assertThat(doesEmployeeExist).isEqualTo(false);  
        . assertThat(fromDb.getName()).isEqualTo("john");  
        . assertThat(fromDb).isNull();  
        . assertThat(allEmployees).hasSize(3).extracting(Employee::getName).contains(alex.getName(), john.getName(), bob.getName());  

## b) Identify an example in which you mock the behavior of the repository (and avoid involving a database). 

    In EmployeeService_UnitTest.java the behaviour of the repository is being mocked.  
    The mocked repository is being used to perform several tests and confirm that it is working properly, meaning that,  
    the repository is being tested without the need of an operating database.

```java

@Mock( lenient = true)
private EmployeeRepository employeeRepository;

```

## c) What is the difference between standard @Mock and @MockBean?

    @Mock : Mockito Library  
    Only needs JUnit and Mockito and allows to mock a class or interface and to test with it. 
  
    @MockBean : Spring Boot Library  
    Allows to add Mockito mocks in a Spring ApplicationContext.  
    If a bean, exists in the context, it replaces it by the mock.  
    If not, it adds the mock in the context as a bean.  

    The main difference between @Mock and @MockBean is that @Mock should be used when unit testing our business model (only using JUnit and Mockito).  
    And @MockBean should be used when we are writing a test and we need to add or replace a bean with a mocked version of it.  

## d) What is the role of the file “application-integrationtest.properties”? In which conditions will it be used?

    The "application-integrationtest.properties" file has a set of application properties that the tests should abide to.  
    If we want to use a real database for our tests the connection defined in the application properties is essential because in there  
    we have (or should have) the properties needed to connect to a database.
